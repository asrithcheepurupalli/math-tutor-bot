"""
Video Generator module for Math Tutor Bot
Handles Google Veo API calls to create educational videos
"""

import os
import logging
import asyncio
import json
import tempfile
from typing import Dict, Any, Optional, List
from datetime import datetime
import requests
import time

# Google Cloud Video Intelligence (optional)
try:
    from google.cloud import videointelligence
    HAS_GOOGLE_CLOUD = True
except ImportError:
    HAS_GOOGLE_CLOUD = False

# Video generation libraries (with fallbacks)
try:
    from moviepy.editor import VideoFileClip, TextClip, CompositeVideoClip, ColorClip
    HAS_MOVIEPY = True
except ImportError:
    HAS_MOVIEPY = False

try:
    import matplotlib.pyplot as plt
    import matplotlib.patches as patches
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False

try:
    from PIL import Image, ImageDraw, ImageFont
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

try:
    import numpy as np
    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False

from dotenv import load_dotenv

load_dotenv()

class VideoGenerator:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Configuration
        self.project_id = os.getenv('GOOGLE_CLOUD_PROJECT_ID')
        self.credentials_path = os.getenv('GOOGLE_CLOUD_CREDENTIALS_PATH')
        self.veo_api_key = os.getenv('GOOGLE_VEO_API_KEY')
        self.output_dir = os.getenv('VIDEO_OUTPUT_DIR', './generated_videos')
        self.max_duration = int(os.getenv('MAX_VIDEO_DURATION', 60))
        self.resolution = os.getenv('VIDEO_RESOLUTION', '720p')
        
        # Create output directory
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Video settings based on resolution
        self.video_settings = {
            '480p': {'width': 854, 'height': 480, 'fps': 24},
            '720p': {'width': 1280, 'height': 720, 'fps': 30},
            '1080p': {'width': 1920, 'height': 1080, 'fps': 30}
        }
        
        self.current_settings = self.video_settings.get(self.resolution, self.video_settings['720p'])
        
        self.logger.info(f"VideoGenerator initialized with resolution: {self.resolution}")
        
        # Check available features
        if not HAS_MOVIEPY:
            self.logger.warning("MoviePy not available - video generation will be limited")
        if not HAS_MATPLOTLIB:
            self.logger.warning("Matplotlib not available - mathematical visualizations disabled")
        if not HAS_PIL:
            self.logger.warning("PIL not available - image processing limited")
    
    async def create_explanation_video(
        self, 
        problem: str, 
        solution: str, 
        steps: List[str], 
        user_id: int,
        include_original_image: Optional[str] = None
    ) -> Optional[str]:
        """
        Create an educational video explanation using Google Veo or fallback methods
        
        Args:
            problem: The original math problem
            solution: The solution
            steps: List of solution steps
            user_id: User ID for file naming
            include_original_image: Optional path to original problem image
            
        Returns:
            Path to generated video file or None if generation fails
        """
        try:
            self.logger.info(f"Creating video for user {user_id}")
            
            # Generate video script
            video_script = self._create_video_script(problem, solution, steps)
            
            # Try Google Veo first, then fallback to local generation
            video_path = await self._try_google_veo_generation(
                video_script, problem, user_id
            )
            
            if not video_path:
                self.logger.info("Google Veo unavailable, using local video generation")
                video_path = await self._create_local_video(
                    problem, solution, steps, user_id, include_original_image
                )
            
            return video_path
            
        except Exception as e:
            self.logger.error(f"Error creating video: {str(e)}")
            return None
    
    async def _try_google_veo_generation(
        self, script: str, problem: str, user_id: int
    ) -> Optional[str]:
        """
        Try to generate video using Google Veo API
        Note: This is a placeholder implementation as Google Veo API is still in development
        """
        try:
            if not self.veo_api_key:
                self.logger.info("Google Veo API key not configured")
                return None
            
            # Placeholder for Google Veo API call
            # When Veo API becomes available, implement actual API calls here
            self.logger.info("Google Veo API not yet available for public use")
            return None
            
            # Future implementation would look like:
            # veo_request = {
            #     "prompt": script,
            #     "duration": min(len(script.split()) * 0.5, self.max_duration),
            #     "resolution": self.resolution,
            #     "style": "educational",
            #     "voice": "professional"
            # }
            # 
            # response = await self._call_veo_api(veo_request)
            # return await self._download_veo_video(response, user_id)
            
        except Exception as e:
            self.logger.warning(f"Google Veo generation failed: {str(e)}")
            return None
    
    async def _create_local_video(
        self, 
        problem: str, 
        solution: str, 
        steps: List[str], 
        user_id: int,
        include_original_image: Optional[str] = None
    ) -> Optional[str]:
        """
        Create video using local tools (MoviePy, matplotlib)
        """
        try:
            if not HAS_MOVIEPY:
                self.logger.warning("MoviePy not available, skipping video generation")
                return None
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            video_filename = f"math_explanation_{user_id}_{timestamp}.mp4"
            video_path = os.path.join(self.output_dir, video_filename)
            
            # Create video scenes
            scenes = []
            
            # Scene 1: Problem introduction
            problem_scene = await self._create_text_scene(
                title="Math Problem",
                content=problem,
                duration=3,
                background_color='navy'
            )
            scenes.append(problem_scene)
            
            # Scene 2: Step-by-step solution
            for i, step in enumerate(steps[:8], 1):  # Limit to 8 steps for video length
                step_scene = await self._create_step_scene(
                    step_number=i,
                    step_content=step,
                    duration=4,
                    total_steps=len(steps)
                )
                scenes.append(step_scene)
            
            # Scene 3: Final solution
            solution_scene = await self._create_text_scene(
                title="Final Answer",
                content=solution,
                duration=3,
                background_color='darkgreen'
            )
            scenes.append(solution_scene)
            
            # Scene 4: Closing
            closing_scene = await self._create_text_scene(
                title="Math Tutor Bot",
                content="Thanks for learning with us!",
                duration=2,
                background_color='purple'
            )
            scenes.append(closing_scene)
            
            # Combine all scenes
            final_video = CompositeVideoClip(scenes, method='compose')
            
            # Add background music or audio (if available)
            # final_video = self._add_audio(final_video)
            
            # Write video file
            final_video.write_videofile(
                video_path,
                fps=self.current_settings['fps'],
                codec='libx264',
                audio_codec='aac',
                verbose=False,
                logger=None
            )
            
            # Clean up temporary clips
            for scene in scenes:
                scene.close()
            final_video.close()
            
            self.logger.info(f"Local video created: {video_path}")
            return video_path
            
        except Exception as e:
            self.logger.error(f"Error creating local video: {str(e)}")
            return None
    
    async def _create_text_scene(
        self, title: str, content: str, duration: int, background_color: str = 'navy'
    ) -> VideoFileClip:
        """Create a text-based video scene"""
        try:
            # Create background
            background = ColorClip(
                size=(self.current_settings['width'], self.current_settings['height']),
                color=background_color,
                duration=duration
            )
            
            # Create title text
            title_clip = TextClip(
                title,
                fontsize=self.current_settings['height'] // 15,
                color='white',
                font='Arial-Bold'
            ).set_duration(duration).set_position(('center', self.current_settings['height'] // 6))
            
            # Create content text (wrap long text)
            wrapped_content = self._wrap_text(content, 60)
            content_clip = TextClip(
                wrapped_content,
                fontsize=self.current_settings['height'] // 25,
                color='white',
                font='Arial',
                method='caption',
                size=(self.current_settings['width'] * 0.8, None)
            ).set_duration(duration).set_position('center')
            
            # Compose the scene
            scene = CompositeVideoClip([background, title_clip, content_clip])
            
            return scene
            
        except Exception as e:
            self.logger.error(f"Error creating text scene: {str(e)}")
            # Return a simple colored clip as fallback
            return ColorClip(
                size=(self.current_settings['width'], self.current_settings['height']),
                color=background_color,
                duration=duration
            )
    
    async def _create_step_scene(
        self, step_number: int, step_content: str, duration: int, total_steps: int
    ) -> VideoFileClip:
        """Create a scene for a solution step"""
        try:
            # Create background
            background = ColorClip(
                size=(self.current_settings['width'], self.current_settings['height']),
                color='darkblue',
                duration=duration
            )
            
            # Create step number
            step_title = f"Step {step_number} of {total_steps}"
            title_clip = TextClip(
                step_title,
                fontsize=self.current_settings['height'] // 20,
                color='yellow',
                font='Arial-Bold'
            ).set_duration(duration).set_position(('center', self.current_settings['height'] // 8))
            
            # Create step content
            wrapped_content = self._wrap_text(step_content, 50)
            content_clip = TextClip(
                wrapped_content,
                fontsize=self.current_settings['height'] // 30,
                color='white',
                font='Arial',
                method='caption',
                size=(self.current_settings['width'] * 0.85, None)
            ).set_duration(duration).set_position('center')
            
            # Create progress bar
            progress_width = int((step_number / total_steps) * self.current_settings['width'] * 0.8)
            progress_bar = ColorClip(
                size=(progress_width, 10),
                color='green',
                duration=duration
            ).set_position((self.current_settings['width'] * 0.1, self.current_settings['height'] * 0.9))
            
            # Progress bar background
            progress_bg = ColorClip(
                size=(int(self.current_settings['width'] * 0.8), 10),
                color='gray',
                duration=duration
            ).set_position((self.current_settings['width'] * 0.1, self.current_settings['height'] * 0.9))
            
            # Compose the scene
            scene = CompositeVideoClip([background, progress_bg, progress_bar, title_clip, content_clip])
            
            return scene
            
        except Exception as e:
            self.logger.error(f"Error creating step scene: {str(e)}")
            return ColorClip(
                size=(self.current_settings['width'], self.current_settings['height']),
                color='darkblue',
                duration=duration
            )
    
    def _wrap_text(self, text: str, max_chars_per_line: int) -> str:
        """Wrap text to fit within specified character limit per line"""
        words = text.split()
        lines = []
        current_line = []
        current_length = 0
        
        for word in words:
            if current_length + len(word) + 1 <= max_chars_per_line:
                current_line.append(word)
                current_length += len(word) + 1
            else:
                if current_line:
                    lines.append(' '.join(current_line))
                current_line = [word]
                current_length = len(word)
        
        if current_line:
            lines.append(' '.join(current_line))
        
        return '\n'.join(lines)
    
    def _create_video_script(self, problem: str, solution: str, steps: List[str]) -> str:
        """Create a video script for Google Veo"""
        script_parts = [
            f"Welcome to Math Tutor! Today we'll solve: {problem}",
            "",
            "Let's work through this step by step:",
        ]
        
        for i, step in enumerate(steps, 1):
            script_parts.append(f"Step {i}: {step}")
        
        script_parts.extend([
            "",
            f"And our final answer is: {solution}",
            "Great job! Keep practicing math with Math Tutor Bot!"
        ])
        
        return " ".join(script_parts)
    
    async def _create_mathematical_visualization(
        self, problem: str, steps: List[str]
    ) -> Optional[str]:
        """
        Create mathematical visualizations using matplotlib
        (for geometry problems, graphs, etc.)
        """
        try:
            if not HAS_MATPLOTLIB:
                self.logger.warning("Matplotlib not available for visualization")
                return None
                
            # This is a placeholder for mathematical visualization
            # Implementation would depend on problem type detection
            
            fig, ax = plt.subplots(figsize=(10, 8))
            ax.text(0.5, 0.7, problem, ha='center', va='center', fontsize=16, wrap=True)
            ax.text(0.5, 0.3, "Solution steps visualization", ha='center', va='center', fontsize=14)
            ax.set_xlim(0, 1)
            ax.set_ylim(0, 1)
            ax.axis('off')
            
            # Save as image
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            image_path = os.path.join(self.output_dir, f"math_viz_{timestamp}.png")
            plt.savefig(image_path, bbox_inches='tight', dpi=150)
            plt.close()
            
            return image_path
            
        except Exception as e:
            self.logger.error(f"Error creating mathematical visualization: {str(e)}")
            return None
    
    def cleanup_old_videos(self, max_age_hours: int = 24):
        """Clean up old video files to save disk space"""
        try:
            current_time = time.time()
            max_age_seconds = max_age_hours * 3600
            
            for filename in os.listdir(self.output_dir):
                file_path = os.path.join(self.output_dir, filename)
                if os.path.isfile(file_path):
                    file_age = current_time - os.path.getctime(file_path)
                    if file_age > max_age_seconds:
                        os.remove(file_path)
                        self.logger.info(f"Cleaned up old video: {filename}")
                        
        except Exception as e:
            self.logger.error(f"Error cleaning up videos: {str(e)}")
    
    async def get_video_info(self, video_path: str) -> Dict[str, Any]:
        """Get information about a generated video"""
        try:
            if not HAS_MOVIEPY:
                return {'error': 'MoviePy not available'}
                
            clip = VideoFileClip(video_path)
            info = {
                'duration': clip.duration,
                'fps': clip.fps,
                'size': (clip.w, clip.h),
                'file_size': os.path.getsize(video_path),
                'created': datetime.fromtimestamp(os.path.getctime(video_path)).isoformat()
            }
            clip.close()
            return info
        except Exception as e:
            self.logger.error(f"Error getting video info: {str(e)}")
            return {}
